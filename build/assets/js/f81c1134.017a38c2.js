"use strict";(self.webpackChunkcgg_labs_docs=self.webpackChunkcgg_labs_docs||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"foc","metadata":{"permalink":"/blog/foc","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-05-03-foc.md","source":"@site/blog/2025-05-03-foc.md","title":"Field Oriented Control (FOC)","description":"Field Oriented Control is often considered a dark art filled with diagrams, math, and proofs by intimidation.","date":"2025-05-03T00:00:00.000Z","tags":[{"inline":false,"label":"Motors","permalink":"/blog/tags/motors","description":"Motors tag description"},{"inline":false,"label":"FOC","permalink":"/blog/tags/foc","description":"FOC tag description"}],"readingTime":18.27,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"foc","title":"Field Oriented Control (FOC)","authors":"carlos","tags":["Motors","FOC"],"draft":false},"unlisted":false,"nextItem":{"title":"How does a BLDC motor work?","permalink":"/blog/bldc"}},"content":"Field Oriented Control is often considered a dark art filled with diagrams, math, and proofs by intimidation. \\n\\nOften people will show a diagram like this,\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![FOC Diagram](/img/foc-block-diagram.png)\\n\\n</div>\\n\\nand pretend like it\'s self explanatory.\\n\\nNot true!\\n\\nHowever, once you get an understanding of what the different pieces are and what they are trying to do, you\'ll realize that it can be quite intuitive.\\n\\nLet\'s dive in.\\n\\n\x3c!-- truncate --\x3e\\n\\n## 1. How does a motor work?\\n\\nLet\'s start with the humble goal of understanding how a motor works.\\n\\nWhen you run a current through a wire, you get a magnetic field around the wire.\\n\\n<div style={{textAlign: \'center\'}}>\\n![Magnetic field around a current-carrying wire](/img/faradays-law.jpg)\\n</div>\\n\\nIf I put a permanent magnet like a compass next to the wire, the magnetic field of the compass interacts with the magnetic field around the wire which causes the compass to be deflected. \\n\\n<div style={{textAlign: \'center\'}}>\\n![Wire deflecting compass](/img/wire-deflecting-compass.gif)\\n</div>\\n\\nThis is a result of the north and south poles of each field being attracted to each other and trying to align.\\n\\nA motor works in the same way.\\n\\n<div style={{textAlign: \'center\'}}>\\n![Brushless Motor](/img/BLDC-Motor.gif)\\n</div>\\n\\nInside of the motor there are both permanent magnets and wires. When you run a current through the wires inside the motor, the magnetic field of the wire interacts with the magnetic field of the permanent magnets - just like the compass and wire we talked about before.\\n\\n\\n### 1.1 Motor Terminology\\nThere are two main parts of a motor: a rotor and a stator. \\n\\n<div style={{textAlign: \'center\'}}>\\n![PMSM](/img/pmsm.png)\\n</div>\\n\\nThe rotor is free to rotate and the stator is stationary.\\n\\nThe permanent magnets are attached to the rotor and the wire is wrapped around specific parts of the stator.\\n\\nNow if I start to run current through the wire, I get a magnetic field that starts to interact with the magnetic field of the permanent magnets. Since the permanent magnets on the rotor are free to rotate, the rotor will rotate to try to align its magnetic field with the one created by the wire. \\n\\nAnd so, we get a rotation. Success!\\n\\nThis type of motor is called a Brushless DC motor (BLDC) and a variant of it called a Permanent Magnet Synchronous Motor (PMSM) is what we\'ll be focusing on in this post.\\n\\nDepending on the motor design, there may also be sensors like hall-effect sensors or encoders inside the motor that provide position data. We\'ll touch on these later.\\n\\n\\n## 2. How to spin efficiently\\nOkay, so we know that putting current through the motor wires makes the motor spin, but how do we know when to stop running current through one set of wires and run it through a different set of wires so that the motor can keep spinning? \\n\\nIf you take a step back for a second and think about what we want to do, the ideal direction for the force that we want to apply is for it to be tangential to the rotor like this: \\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![tangent motor force](/img/tangent-motor-force.png)\\n\\n</div>\\n\\nThis maximizes the torque applied to the rotor and makes it so that all of the force (and energy!) that we use goes to achieving our goal of rotating the rotor. \\n\\nSo if we can get the magnetic fields created by the currents in the wire to interact with the permanent magnets in such a way that the magnetic force is applied tangentially to the rotor, then we know we are driving the motor in an efficient way.\\n\\n## 3. How does FOC do that?\\n\\n**The core idea of FOC is to continuously adjust the stator currents so that the magnetic field they produce is always 90\xb0 orthogonal to the rotor\u2019s field.**\\n\\nIf you only take one thing away from reading this, let it be that previous statement.\\n\\nThe goal of all of the fancy math, sensors, and PI controllers is to make sure that statement holds as close to true as possible at all times during the motor\'s operation.\\n\\n*FOC does this by converting to a frame of reference where it is easy to compare the stator current magnetic field to the rotor magnetic field.* \\n\\nOnce you have an easy way of comparing the two magnetic fields, you can start to do controls and move the stator current magnetic field so that it \\"pushes\\" the rotor\'s magnetic field in a faster or slower way - thus varying the speed of the motor. \\n\\nTo see more clearly how FOC is doing this, we have to dig a little deeper.\\n\\n## 4. Digging deeper\\n\\nIn this section we\'re going to get into the specifics of FOC along with all the math, etc. \\n\\nOur goal is to get a smoothly rotating magnetic field like this to be created by only changing the currents flowing though the 3 windings.\\n<div style={{textAlign: \'center\'}}>\\n\\n![Smooth FOC](/img/pmsm_3_phase.gif)\\n\\n</div>\\n\\nThe green, red, and dark blue lines are vectors representing the magnetic field created by the current flowing through each winding and the cyan line is the combined magnetic field resulting from the interaction of the 3 magnetic fields.\\n\\nThe important thing to see here is that the cyan vector is smoothly rotating around the circle which results in the magnetic field from the stator currents being applied tangentially to the permanent magnets like we want.\\n\\nIt might take a couple of reads for everything in this section to click, but just keep in mind the concepts from the previous section if you get stuck.\\n\\n### 4.1 Motor Schematic\\nA PMSM motor can be modeled electrically as follows,\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![Motor schematic](/img/motor-windings-schematic.png)\\n\\n</div>\\n\\nThis is our initial frame of reference where we can measure stator currents and output stator voltages.\\n\\nIf we apply Kirchoff\'s current law at the point in the middle of where the 3 windings meet, we get the following equation,\\n$$\\ni_a(t) + i_b(t) + i_c(t) = 0\\n$$\\n\\n*This equation is very important.*\\n\\nWhat this is saying is that even though we have 3 axes (one for each winding that the current can flow through), we only have 2 degrees of freedom.\\n\\nSo why is this important?\\n\\n### 4.2 Clarke, Park, and friends\\n\\nWhat we are looking for is a way to represent the magnetic field created by the 3 phase currents using a reference frame with two axes: one that is aligned with the magnetic field of the rotor and another that is perpendicular to the first axis.\\n\\nThe second axis would give us the direction to apply a force in order to maximize the torque to spin the motor. \\n\\nThis would allow us to control the torque being applied to the rotor by changing the 3 phase currents.\\n\\nSomething like this would be ideal:\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![Id-Iq axes](/img/motor-id-iq-axes.png)\\n\\n</div>\\n\\nThis is what the Clarke and Park transforms allow us to do.\\n\\n\\n#### 4.2.1 Clarke Transform\\n\\nThe Clarke transform maps the 3 stator current axes into 2 axes called $\\\\alpha$ and $\\\\beta$.\\n$$\\n\\\\begin{aligned}\\ni_\\\\alpha &= i_a, \\\\\\\\[6pt]\\ni_\\\\beta  &= \\\\frac{1}{\\\\sqrt{3}}\\\\bigl(i_a + 2\\\\,i_b\\\\bigr).\\n\\\\end{aligned}\\n$$\\n\\n*The only reason we can map 3 axes into 2 axes without losing any information is because we only have 2 degrees of freedom (not 3) like we saw in the last section from Kirchoff\'s law.*\\n\\nAlso notice that there isn\'t anything special about the current here. We can also do the same thing with the phase voltages to get,\\n$$\\n\\\\begin{aligned}\\nv_\\\\alpha &= v_a, \\\\\\\\[6pt]\\nv_\\\\beta  &= \\\\frac{1}{\\\\sqrt{3}}\\\\bigl(v_a + 2\\\\,v_b\\\\bigr).\\n\\\\end{aligned}\\n$$\\n\\nThese equations might seem mysterious at first, but look a bit closer: the $\\\\alpha$ axis is aligned with $a$ and axes $b$ and $c$ are projected into a single axis $\\\\beta$ that is perpendicular to $\\\\alpha$ (and thus also perpendicular to $a$). \\n\\nIf you\'re familiar with linear algebra, this is doing what\'s called a change of basis. In fact, in matrix form the current can be expressed like this,\\n\\n$$\\n\\\\begin{bmatrix}\\ni_\\\\alpha \\\\\\\\[4pt]\\ni_\\\\beta\\n\\\\end{bmatrix}\\n=\\n\\\\frac{2}{3}\\\\,\\n\\\\begin{bmatrix}\\n1 & -\\\\tfrac12 & -\\\\tfrac12 \\\\\\\\[4pt]\\n0 & \\\\tfrac{\\\\sqrt{3}}{2} & -\\\\tfrac{\\\\sqrt{3}}{2}\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\ni_a \\\\\\\\[4pt]\\ni_b \\\\\\\\[4pt]\\ni_c\\n\\\\end{bmatrix}\\n$$\\n\\nGeometrically, this gets us to here.\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![alpha beta frame](/img/foc-alpha-beta-frame.gif)\\n\\n</div>\\n\\nThat\'s a good start, but this would still require us to control two sinusoidal waves when doing control. \\n\\nCan we make the control easier with another change of reference frame?\\n\\n#### 4.2.2 Park Transform\\nIt turns out that we can.\\n\\nIf you think about it, the sinusoidal waves are coming from the fact that in the current frame of reference, the current vector is rotating.\\n\\nBut what if we make the entire frame of reference rotate?\\n\\nIf we can transform the alpha-beta frame into a frame of reference that rotates, then from this new frame of reference, the current is not rotating. In fact, it would look stationary.\\n\\nWhat we want is something like this:\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![alpha beta frame](/img/foc-iq-id-frame.gif)\\n\\n</div>\\n\\nThis is what the Park transform gives us.\\n\\nBy doing another change of basis, we can make the signals that we want to control look as though they are DC signals. \\n\\n$$\\n\\\\begin{bmatrix}\\ni_d \\\\\\\\\\ni_q\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n\\\\cos\\\\theta & \\\\sin\\\\theta \\\\\\\\\\n-\\\\sin\\\\theta & \\\\cos\\\\theta\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\ni_\\\\alpha \\\\\\\\\\ni_\\\\beta\\n\\\\end{bmatrix}\\n$$\\n\\nThis is great, because controlling DC signals is straightforward.\\n\\nIn this frame of reference, $i_d$ is called the direct axis current which represents how much current is aligned with the rotor\u2019s field (producing no torque, just magnetizing or de-magnetizing by modifying the magnetic flux). $i_q$ is the quadrature axis current and is perpendicular to the rotor\u2019s magnetic field (producing torque).\\n\\nIn our case, we want all torque and no extra magnetization, so we want $i_d = 0$ and we want $i_q$ to be whatever is needed for the desired torque. \\n\\nStop for a second and think about this. What we\'ve done here is pretty incredible. We now are able to command the exact torque and flux we want from the motor in a non-coupled *time invariant* way using only the stator currents.\\n\\nAs we\'ll see later, this allows us to control the flux and torque like DC quantities using classical PI regulators.\\n\\nThis is the whole reason for using Field Oriented Control: *AC phase currents get controlled via DC targets in the rotating d\u2013q frame.*\\n\\n#### 4.2.3 Inverse Transforms\\nAn important feature of the Clarke and Park transforms is that they can be inverted. Remember, we didn\'t lose any information so we should be able to \\"undo\\" the transformation.\\n\\n\\nRearranging the Park transformation above we can solve for the Inverse Park Transform to get,\\n$$\\n\\\\begin{bmatrix}\\ni_\\\\alpha \\\\\\\\[4pt]\\ni_\\\\beta\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n\\\\cos\\\\theta & -\\\\sin\\\\theta \\\\\\\\[6pt]\\n\\\\sin\\\\theta & \\\\;\\\\;\\\\cos\\\\theta\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\ni_d \\\\\\\\[4pt]\\ni_q\\n\\\\end{bmatrix}\\n$$\\n\\n\\nSimilarly for the inverse Clarke transform we get,\\n$$\\n\\\\begin{bmatrix}\\ni_a \\\\\\\\[4pt]\\ni_b \\\\\\\\[4pt]\\ni_c\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n1 & 0 \\\\\\\\[6pt]\\n-\\\\tfrac12 & \\\\tfrac{\\\\sqrt{3}}{2} \\\\\\\\[6pt]\\n-\\\\tfrac12 & -\\\\tfrac{\\\\sqrt{3}}{2}\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\ni_\\\\alpha \\\\\\\\[4pt]\\ni_\\\\beta\\n\\\\end{bmatrix}\\n$$\\n\\nHowever in practice, we use the inverse Clarke and inverse Park transforms to get phase voltages, not phase currents. This is because we can\'t directly command a current, but we can directly command a voltage by turning the FETs on the inverter on and off using PWM.\\n\\nThus in practice you\'ll see this version of the inverse Park transform,\\n\\n$$\\n\\\\begin{bmatrix}\\nv_\\\\alpha \\\\\\\\[4pt]\\nv_\\\\beta\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n\\\\cos\\\\theta & -\\\\sin\\\\theta \\\\\\\\[6pt]\\n\\\\sin\\\\theta & \\\\;\\\\;\\\\cos\\\\theta\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\nv_d \\\\\\\\[4pt]\\nv_q\\n\\\\end{bmatrix}\\n$$\\n\\nand this version of the inverse Clarke transform,\\n$$\\n\\\\begin{bmatrix}\\nv_a \\\\\\\\[4pt]\\nv_b \\\\\\\\[4pt]\\nv_c\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n1 & 0 \\\\\\\\[6pt]\\n-\\\\tfrac12 & \\\\tfrac{\\\\sqrt{3}}{2} \\\\\\\\[6pt]\\n-\\\\tfrac12 & -\\\\tfrac{\\\\sqrt{3}}{2}\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\nv_\\\\alpha \\\\\\\\[4pt]\\nv_\\\\beta\\n\\\\end{bmatrix}\\n$$\\n\\n\\n\\nNow that we have a way to turn our stator currents into DC signals (and back), it\'s time for controls.\\n\\n### 4.3 Speed loop and Current loop\\n\\nThere are three PI loops in most FOC implementations: the (outer) speed loop and two (inner) current loops.\\n\\nThe outer speed loop takes the commanded speed that we *want* the motor to spin at, compares it with the measured speed, and uses a PI controller to output a commanded torque (in the form of a current since current is proportional to torque).\\n\\nThe inner current loop $i_q$ takes the output current of the speed controller, compares it with the measured current that we get from transforming the phase currents using the Clarke and Park transforms into the $d$-$q$ axis, runs this through a PI controller, and hands this off to the inverse Park transform to eventually be fed to the inverter FETs after Space Vector Modulation. \\n\\nOn the other hand, for our use case, the inner current loop $i_d$ will always be driven to zero. This is because any current on the $i_d$ axis would waste energy since it would not contribute to maximizing the torque generated by the stator current magnetic field.\\n\\n### 4.4 Position and Speed\\nI\'m going to keep this section short since the way you get a position and speed estimate of the rotor is heavily motor dependent.\\n\\nBroadly, there are two ways you can get estimates for speed and position: sensored and unsensored.\\n\\nIn the unsensored case, you\'ll run the voltage and current values of each phase in the $\\\\alpha$-$\\\\beta$ frame into either a sliding mode observer or a Kalman filter of some kind. Sliding mode observers are more common since they tend to be easier to tune.\\n\\nIn the sensored case, you\'ll use either a hall effect sensor or an encoder to get the position of the motor. Hall effect sensors don\'t have as high of resolution as an encoder but they are good enough at low speeds where the back-emf and currents are hard to discern from noise. \\n\\nIn either case, you can take the delta of subsequent position estimates to get an estimate for speed. \\n\\nRegardless of how you go about getting your estimates for speed and position, speed gets fed to the speed controller and position gets fed to the Park transform.\\n\\n### 4.5\xa0PWM Generation\\n\\nGreat, the inverse\xa0Park transform gave us the stator\u2011voltage vector we want \u2013 but how do we turn that into real gate signals for the three half\u2011bridges?\\n\\nThere are two ways of doing this: \\n1. using the inverse Clarke Transform and normalising each per\u2011phase reference to the DC\u2011bus voltage to get a duty\u2011cycle between\u202f0\u202fand\u202f1 \\n2. Space vector pulse width modulation\\n\\nLet\'s look at each in turn.\\n\\n#### 4.5.1 Inverse Clarke and Normalizing\\n\\nThis is the most straightforward approach.\\n\\nFirst let\'s use the inverse Clarke transform to transform the desired voltage vectors back to the $a-b-c$ frame,\\n\\n$$\\n\\\\begin{aligned}\\nv_a &= v_\\\\alpha \\\\\\\\[6pt]\\nv_b &= -\\\\frac{1}{2}\\\\,v_\\\\alpha + \\\\frac{\\\\sqrt{3}}{2}\\\\,v_\\\\beta \\\\\\\\[6pt]\\nv_c &= -\\\\frac{1}{2}\\\\,v_\\\\alpha - \\\\frac{\\\\sqrt{3}}{2}\\\\,v_\\\\beta\\n\\\\end{aligned}\\n$$\\n\\nNow let\'s normalize those to our PWMs,\\n$$\\nD_x \\\\;=\\\\; \\\\frac{v_x}{V_{\\\\mathrm{dc}}} \\\\;+\\\\; \\\\frac{1}{2},\\n\\\\qquad x\\\\in\\\\{a,b,c\\\\}\\n$$\\n\\nThese are the duty cycles that we use to command our FETs. \\n\\nNote that we are assuming that the duty ranges from 0 to 1 and that the inverter produces a phase voltage ranging from $-\\\\frac{1}{2}V_{dc}$ to $\\\\frac{1}{2}V_{dc}$.\\n\\nIn practice, I stick with this approach for generating the PWMs over SVPWM because of its simplicity.\\n\\n#### 4.5.2 Space Vector Pulse Width Modulation (SVPWM)\\n\\nSVPWM is more involved but tries to achieve the same thing. \\n\\nIt takes the continuous voltage vector  \\n $$\\n \\\\mathbf v_s =\\n \\\\begin{bmatrix}\\n v_\\\\alpha \\\\\\\\[2pt] v_\\\\beta\\n \\\\end{bmatrix},\\n \\\\qquad\\n 0 \\\\le \\\\lVert \\\\mathbf v_s \\\\rVert \\\\le \\\\tfrac{V_\\\\text{dc}}{\\\\sqrt{3}},\\n $$\\nand spits out a pattern of on/off times inside the next PWM period\xa0$T_s$.\\n\\n##### 4.5.2.1 The eight inverter states\\n\\nNote that with three inverter legs there are $2^3 = 8$ switch combinations.  \\n\\nSix are *active* vectors that form a hexagon in the $\\\\alpha$\u2013$\\\\beta$ plane; two are *zero* vectors at the origin.\\n\\n| Vector | $S_aS_bS_c$ | Normalised $(v_\\\\alpha , v_\\\\beta)$ |\\n|-------|:-------------:|-----------------------------------|\\n| $V_0$ | 000 | (0\xa0,\xa00) \xa0*zero* |\\n| $V_1$ | 100 | (1\xa0,\xa00) |\\n| $V_2$ | 110 | (\xbd\xa0,\xa0$\\\\sqrt{3}/2$) |\\n| $V_3$ | 010 | (\u2011\xbd,\xa0$\\\\sqrt{3}/2$) |\\n| $V_4$ | 011 | (\u20111\xa0,\xa00) |\\n| $V_5$ | 001 | (\u2011\xbd,\xa0\u2011$\\\\sqrt{3}/2$) |\\n| $V_6$ | 101 | (\xbd\xa0,\xa0\u2011$\\\\sqrt{3}/2$) |\\n| $V_7$ | 111 | (0\xa0,\xa00) \xa0*zero* |\\n\\n<div style={{textAlign: \'center\'}}>\\n  ![SVPWM hexagon](/img/svpwm-hexagon.jpg)\\n</div>\\n\\nAny point inside that hexagon can be expressed as a time\u2011weighted average of the **two** adjacent active vectors plus a zero vector.\\n\\n##### 4.5.2.3 Finding the sector\\n\\nCompute the angle of $\\\\mathbf v_s$:\\n\\n$$\\n\\\\theta_\\\\alpha = \\\\operatorname{atan2}(v_\\\\beta , v_\\\\alpha).\\n$$\\n\\nDivide the circle into six $60^\\\\circ$ slices to get the sector:\\n\\n$$\\n\\\\text{sector} =\\n\\\\Bigl\\\\lfloor \\\\tfrac{3}{\\\\pi}\\\\,\\\\theta_\\\\alpha \\\\Bigr\\\\rfloor \\\\bmod 6.\\n$$\\n\\nNote that most of the time you can avoid `atan2` entirely \u2013 a lookup table or incremental counter is cheaper and accurate enough.\\n\\n##### 4.5.2.4 Dwell-time algebra\\n\\nLet $V_k$ and $V_{k+1}$ be the two active vectors that bound the sector.  \\n\\nDuring one PWM period $T_s$:\\n\\n$$\\n\\\\mathbf v_s T_s\\n= V_k T_1 + V_{k+1} T_2 + V_\\\\text{zero} T_0,\\n\\\\qquad\\nT_0 = T_s - T_1 - T_2.\\n$$\\n\\nUsing the unit coordinates $(\\\\alpha_k,\\\\beta_k)$ of $V_k$ and $(\\\\alpha_{k+1},\\\\beta_{k+1})$ of $V_{k+1}$:\\n\\n$$\\n\\\\begin{aligned}\\nT_1 &= \\\\frac{T_s}{V_\\\\text{dc}}\\n      \\\\bigl( v_\\\\alpha \\\\beta_{k+1} - v_\\\\beta \\\\alpha_{k+1} \\\\bigr),\\\\\\\\[6pt]\\nT_2 &= \\\\frac{T_s}{V_\\\\text{dc}}\\n      \\\\bigl(-v_\\\\alpha \\\\beta_{k}   + v_\\\\beta \\\\alpha_{k}   \\\\bigr).\\n\\\\end{aligned}\\n$$\\n\\nBoth are guaranteed non\u2011negative and their sum never exceeds\xa0$T_s$.\\n\\nWe usually split the zero time symmetrically:\\n\\n$$\\n\\\\tfrac{T_0}{2} \\\\;-\\\\; T_1 \\\\;-\\\\; T_2 \\\\;-\\\\; \\\\tfrac{T_0}{2},\\n$$\\n\\nyielding the familiar *A\u2013B\u2013C\u2013B\u2013A* sequence that minimises switch transitions and makes dead\u2011time insertion trivial.\\n\\n\\n##### 4.5.2.5 Turning dwell times into compare values\\n\\nCentre\u2011aligned timers make the math easy.  \\nIf the counter counts from\xa00\xa0to $T_s/2$ then back to\xa00:\\n\\n$$\\n\\\\text{compare}_a = \\\\frac{T_0}{4} + T_1 + T_2,\\\\quad\\n\\\\text{compare}_b = \\\\frac{T_0}{4} + T_2,\\\\quad\\n\\\\text{compare}_c = \\\\frac{T_0}{4}.\\n$$\\n\\nMultiply by the timer\u2019s *counts\u2011per\u2011period* to get the integers you actually drop into the PWM registers.\\n\\n##### 4.5.2.6 Why bother with SVPWM?\\n\\n* **15\u202f% more headroom** \u2013 SVPWM\u2019s hexagon lets you utilise the DC bus up to $V_\\\\text{dc}/\\\\sqrt{3}$ (\u2248\u202f1.155\xd7 sine\u2011PWM).  \\n* **Cleaner spectrum** \u2013 dominant harmonics move to $3 \\\\times$ the switching frequency, above most audible and control\u2011bandwidth concerns.  \\n* **Fixed switching frequency** \u2013 only the compare values change, so current ripple is predictable.\\n\\nAs a rule of thumb, if your MCU can sample three phase currents and run Clarke/Park math at 20\u202fkHz, it already has the horsepower for SVPWM.\\n\\nWhether SVPWM is worth the hassle is up to you.\\n\\n## 5. Understanding the block diagram\\n\\nNow we can take a look at a standard FOC diagram and try to make sense of it.\\n\\n<div style={{textAlign: \'center\'}}>\\n\\n![FOC Block Diagram](/img/foc-block-diagram.png)\\n\\n</div>\\n\\nEverything that\'s here we\'ve discussed at a high level, so let\'s break it down piece by piece and walk through one iteration of the FOC controller to make things sink in.\\n\\nFirst of all, on the right hand side in gray we have the path from the voltage supply to the inverter to the motor. Without this path, we wouldn\'t have a way of getting current through the inverter and into the motor. Simple enough, moving on.\\n\\nNext we have the position feedback from the motor. Like we discussed before, this can come from either sensors inside the motor or something like a sliding mode observer (not shown in the diagram). These allow us to get an estimate of the angular speed to give to the speed controller as well as the angular position to give to the Park and inverse Park transforms.\\n\\nThe Clarke transform takes the phase current measurements, turns them into the $\\\\alpha$-$\\\\beta$ frame, and passes them to the Park transform. The Park transform takes these, converts them into the $d$-$q$ frame  \\n\\nNext we have the outer speed loop. This takes the motor\'s measured speed as well as the commanded speed and runs it through a PI controller. The difference between the measured speed and the commanded speed is what is considered the error and is what we are trying to drive to zero. The output of this controller is run through the MTPA to check to make sure that the current being commanded is below the maximum limit and the result is passed into the inner current control loop that is controlling $i_q$. \\n\\nLike we mentioned earlier, the first current loop controller drives the $i_d$ current to zero in order to not waste any energy driving current in a direction that does not produce torque. \\n\\nThe other current loop $i_q$ takes the output of the MTPA (or speed loop) as well as the measured current, runs it through a PI controller, and hands it off to the inverse Park transform.\\n\\nThe inverse Park transform takes measured currents as well as the outputs of the current loop controllers and hands that off to the Space Vector generator which converts those into PWM values that are used to command the FETs.\\n\\n### 5.1 Practical Considerations\\nFOC requires relatively powerful microcontrollers in practice due to how fast the PI loops need to be as well as the math that they are performing.\\n\\nThe current loops tend to run around 20KHz in practice while the speed loop tends to run anywhere from 100Hz to 2000Hz. \\n\\nThe current loop needs to be fast enough that to the speed controller the current looks \\"stable\\". Running the current loop around 10 times faster is a heuristic often used in practice since it produces good enough results.\\n\\nIt\'s also important to note that even if you tried to run the speed loop faster, it won\'t make that much of a difference since the current will always be able to change much faster than speed can be modified since getting a motor to spin faster takes a lot longer than getting current to increase.\\n\\n## 6. Closing\\nHopefully this makes FOC a bit less mysterious. The concepts themselves aren\'t too crazy once you see what the different pieces are and how they fit together.\\n\\nAnd remember that FOC is not going anywhere any time soon so if it takes you a couple of passes to understand everything, no big deal. \\n\\nJust keep the big picture in mind and everything will slowly become more clear.\\n\\n![BLDC Mag field](/img/bldc-mag-field.gif)"},{"id":"bldc","metadata":{"permalink":"/blog/bldc","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-05-01-bldc-motor-explained.md","source":"@site/blog/2025-05-01-bldc-motor-explained.md","title":"How does a BLDC motor work?","description":"BLDC Motor","date":"2025-05-01T00:00:00.000Z","tags":[{"inline":false,"label":"Motors","permalink":"/blog/tags/motors","description":"Motors tag description"}],"readingTime":2.325,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"bldc","title":"How does a BLDC motor work?","authors":"carlos","tags":["Motors"],"draft":false},"unlisted":false,"prevItem":{"title":"Field Oriented Control (FOC)","permalink":"/blog/foc"},"nextItem":{"title":"Logging Made Easy","permalink":"/blog/921k6-logger"}},"content":"<div style={{textAlign: \'center\'}}>\\n\\n![BLDC Motor](/img/BLDC-Motor.gif)\\n\\n</div>\\n\\nIt\'s just magnets and wires.\\n\\n\x3c!-- truncate --\x3e\\n\\n## A compass and a wire\\n\\nWhen you run a current through a wire, you get a magnetic field around the wire.\\n\\n<div style={{textAlign: \'center\'}}>\\n![Magnetic field around a current-carrying wire](/img/faradays-law.jpg)\\n</div>\\n\\nIf I put a permanent magnet like a compass next to the wire, the magnetic field of the compass interacts with the magnetic field around the wire which causes the compass to be deflected. \\n\\n<div style={{textAlign: \'center\'}}>\\n![Wire deflecting compass](/img/wire-deflecting-compass.gif)\\n</div>\\n\\nThis is a result of the north and south poles of each field being attracted to each other and trying to align.\\n\\nA motor works in the same way.\\n\\n<div style={{textAlign: \'center\'}}>\\n![Brushless Motor](/img/BLDC-Motor.gif)\\n</div>\\n\\nInside of the motor there are both permanent magnets and wires. When you run a current through the wires inside the motor, the magnetic field of the wire interacts with the magnetic field of the permanent magnets -- just like the compass and wire we talked about before.\\n\\nAs you can see in the image above, there are two main parts of a motor: a rotor and a stator. \\n\\nThe rotor is free to rotate and the stator is stationary.\\n\\nThe permanent magnets are attached to the rotor and the wire is wrapped around specific parts of the stator.\\n\\nNow if I start to run current through the wire, I get a magnetic field that starts to interact with the magnetic field of the permanent magnets. Since the permanent magnets on the rotor are free to rotate, the rotor will rotate to try to align its magnetic field with the one created by the wire. And so, we get a rotation. Success!\\n\\nThis type of motor is called a brushless DC motor. \\n\\nOne thing I want to point out is that in the motor image above current is always flowing through two of the wires. This is because one of the wires always interacts with the south pole (blue in the image) and the other wire interacts with the north pole (red). You can think of this as one magnetic field \\"pushing\\" while the other is \\"pulling\\" since two poles of the same polarity repel each other while poles of opposite polarity attract.\\n\\nLastly, depending on the motor design, there may also be sensors inside the motor that provide position data like hall-effect sensors or encoders.\\n\\n## That\'s it?\\n\\nThis post is purposefully short because I extracted it from a different post that talks about a method for controlling motors called [Field Oriented Control (FOC)](2025-05-03-foc.md).\\n\\nHowever, the explanation was broad enough that it applied to all BLDC motors so I decided to make it its own post.\\n\\nHopefully this makes the inner workings of BLDC motors a bit less mysterious.\\n\\n![PMSM Exploded View](/img/pmsm-exploded-view.jpg)"},{"id":"921k6-logger","metadata":{"permalink":"/blog/921k6-logger","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-14-921k6-logger.md","source":"@site/blog/2025-04-14-921k6-logger.md","title":"Logging Made Easy","description":"Tell me if this sounds familiar:","date":"2025-04-14T00:00:00.000Z","tags":[{"inline":false,"label":"Logging","permalink":"/blog/tags/logging","description":"Logging tag description"},{"inline":false,"label":"Serial","permalink":"/blog/tags/serial","description":"Serial tag description"}],"readingTime":1.205,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"921k6-logger","title":"Logging Made Easy","authors":"carlos","tags":["Logging","Serial"],"draft":false},"unlisted":false,"prevItem":{"title":"How does a BLDC motor work?","permalink":"/blog/bldc"},"nextItem":{"title":"Adding FreeRTOS to an RP2040 Project","permalink":"/blog/rp2040-freertos"}},"content":"Tell me if this sounds familiar:\\n\\nYou\'re working on a project and want to log some UART data. Nothing too crazy though, logging to an SD card will work fine (you\'ve got a few of those lying around anyways). \\n\\n\x3c!-- truncate --\x3e\\n\\nYou look around and find a few boards on Sparkfun that can log data at a baud rate of 115.2k, but you want to log a bit faster than that. I mean, come on, even an RP2040 supports 921.6k baud nowadays.\\n\\nWhy isn\'t there a board that you can just power, plug an SD card into, hook up an RX wire, and log some data at a decent baud rate? \\n\\nNow there is.\\n\\nI\'d like to introduce you the latest thing we\'ve been cooking up in the lab: 921k6 Logger. Just hook up 5V, an RX wire, GND, and everything sent to the RX line will get logged to the SD card. Simple. \\n\\nEven better, with support for exFAT SD cards, you can log to SD cards of any size. No arbitrary 32GB limit from FAT32. We prefer the peace of mind of 128GB because, well, they\'re only 20 bucks nowadays and we\'ll never hit that limit, so why not?\\n\\n3 wires still too many for you? You can plug in the USB for power and GND and only have to connect the RX wire. That makes it easy to power with a standalone battery.\\n\\n[Pick one up today.](https://cgglabs.com/products/921k6-logger)"},{"id":"rp2040-freertos","metadata":{"permalink":"/blog/rp2040-freertos","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-07-adding-freertos-to-an-rp2040-project.md","source":"@site/blog/2025-04-07-adding-freertos-to-an-rp2040-project.md","title":"Adding FreeRTOS to an RP2040 Project","description":"We at CGG Labs love the RP2040","date":"2025-04-07T00:00:00.000Z","tags":[{"inline":false,"label":"RP2040","permalink":"/blog/tags/rp2040","description":"RP2040 tag description"},{"inline":false,"label":"Raspberry Pi Pico","permalink":"/blog/tags/raspberry-pi-pico","description":"Raspberry Pi Pico tag description"},{"inline":false,"label":"FreeRTOS","permalink":"/blog/tags/freertos","description":"FreeRTOS tag description"}],"readingTime":3.755,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"rp2040-freertos","title":"Adding FreeRTOS to an RP2040 Project","authors":"carlos","image":"/img/freertos_blog_post.png","tags":["RP2040","Raspberry Pi Pico","FreeRTOS"]},"unlisted":false,"prevItem":{"title":"Logging Made Easy","permalink":"/blog/921k6-logger"},"nextItem":{"title":"Motors: KT & KV","permalink":"/blog/kt-kv"}},"content":"We at CGG Labs love the RP2040 :heart: \\n\\nHere\'s how to use it with FreeRTOS to unlock the power of full preemptive scheduling.\\n\\n\x3c!-- truncate --\x3e\\nOr you can use our [template](https://github.com/cgglabs/Pico-FreeRTOS) and get on with building. \\n\\n# Adding FreeRTOS to an RP2040 Project in VSCode\\n\\n## Prerequisites\\n\\n- **Pico SDK**: Installed and configured.\\n- **VSCode**: Equipped with [CMake Tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools) and [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) extensions.\\n- **RP2040 Project**: A working project set up in VSCode with the Pico SDK.\\n- **Git**: Installed for cloning FreeRTOS.\\n\\n## Step-by-Step Instructions\\n\\n### 1. Download FreeRTOS\\n\\nClone the FreeRTOS repository or download a release:\\n\\n```bash\\ngit clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules\\n```\\n\\nAlternatively, grab a zip from [FreeRTOS GitHub releases](https://github.com/FreeRTOS/FreeRTOS/releases) and extract it.\\n\\n### 2. Copy FreeRTOS Files to Your Project\\n\\nOrganize FreeRTOS files in your project:\\n\\n- Create a `FreeRTOS` directory in your project root.\\n- Copy the following from the FreeRTOS repository to `FreeRTOS`:\\n  - `FreeRTOS/Source` (core files).\\n  - `FreeRTOS/Source/portable/GCC/ARM_CM0` (Cortex-M0 port for RP2040).\\n  - `FreeRTOS/Source/portable/MemMang/heap_4.c` (heap_4 is a common memory manager; others like `heap_1.c` can also be used).\\n- Copy `FreeRTOS/Source/include` to `FreeRTOS/include`.\\n\\n### 3. Add FreeRTOS Configuration File\\n\\nCreate `FreeRTOSConfig.h` in the `FreeRTOS/include` directory with a minimal configuration:\\n\\n```c\\n#ifndef FREERTOS_CONFIG_H\\n#define FREERTOS_CONFIG_H\\n\\n#define configUSE_PREEMPTION 1\\n#define configUSE_IDLE_HOOK 0\\n#define configUSE_TICK_HOOK 0\\n#define configCPU_CLOCK_HZ 125000000 // 125MHz\\n#define configTICK_RATE_HZ ((TickType_t)1000) // 1ms tick\\n#define configMAX_PRIORITIES (5)\\n#define configMINIMAL_STACK_SIZE ((uint16_t)128)\\n#define configTOTAL_HEAP_SIZE ((size_t)(10 * 1024)) // 10KB heap\\n#define configMAX_TASK_NAME_LEN (16)\\n#define configUSE_16_BIT_TICKS 0\\n#define configIDLE_SHOULD_YIELD 1\\n#define configUSE_MUTEXES 1\\n#define configQUEUE_REGISTRY_SIZE 8\\n\\n/* Memory allocation definitions */\\n#define configSUPPORT_DYNAMIC_ALLOCATION 1\\n#define configSUPPORT_STATIC_ALLOCATION 0\\n\\n/* Interrupt priorities */\\n#define configKERNEL_INTERRUPT_PRIORITY 255\\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY 191\\n\\n/* Map to Pico SDK */\\n#define configUSE_TIMERS 1\\n#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES - 1)\\n#define configTIMER_QUEUE_LENGTH 10\\n#define configTIMER_TASK_STACK_DEPTH configMINIMAL_STACK_SIZE\\n\\n#define configENABLE_MPU 0\\n\\n/* Set the following INCLUDE_* constants to 1 to include the named API function,\\n * or 0 to exclude the named API function.  Most linkers will remove unused\\n * functions even when the constant is 1. */\\n#define INCLUDE_vTaskPrioritySet               1\\n#define INCLUDE_uxTaskPriorityGet              1\\n#define INCLUDE_vTaskDelete                    1\\n#define INCLUDE_vTaskSuspend                   1\\n#define INCLUDE_vTaskDelayUntil                1\\n#define INCLUDE_vTaskDelay                     1\\n#define INCLUDE_xTaskGetSchedulerState         1\\n#define INCLUDE_xTaskGetCurrentTaskHandle      1\\n#define INCLUDE_uxTaskGetStackHighWaterMark    0\\n#define INCLUDE_xTaskGetIdleTaskHandle         0\\n#define INCLUDE_eTaskGetState                  0\\n#define INCLUDE_xTimerPendFunctionCall         0\\n#define INCLUDE_xTaskAbortDelay                0\\n#define INCLUDE_xTaskGetHandle                 0\\n#define INCLUDE_xTaskResumeFromISR             1\\n\\n#endif /* FREERTOS_CONFIG_H */\\n```\\n\\nCustomize `configTOTAL_HEAP_SIZE`, `configMAX_PRIORITIES`, etc., based on your project needs.\\n\\n### 4. Update CMakeLists.txt\\n\\nModify your `CMakeLists.txt` to include FreeRTOS:\\n\\n```cmake\\n# Add FreeRTOS as a library\\nadd_library(freertos\\n    FreeRTOS/Source/croutine.c\\n    FreeRTOS/Source/event_groups.c\\n    FreeRTOS/Source/list.c\\n    FreeRTOS/Source/queue.c\\n    FreeRTOS/Source/stream_buffer.c\\n    FreeRTOS/Source/tasks.c\\n    FreeRTOS/Source/timers.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/port.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/portasm.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/mpu_wrappers_v2_asm.c\\n    FreeRTOS/Source/portable/MemMang/heap_4.c\\n)\\n\\n# Include FreeRTOS headers\\ntarget_include_directories(freertos PUBLIC\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS/include\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS/Source/portable/GCC/ARM_CM0\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS\\n)\\n\\n# Link FreeRTOS to your executable\\ntarget_link_libraries(your_executable_name PRIVATE\\n    pico_stdlib\\n    freertos\\n)\\n```\\n\\n- Replace `your_executable_name` with your target\'s name (from `add_executable`).\\n- Ensure `pico_stdlib` is included for Pico SDK functionality.\\n\\n### 5. (optional) Implement Stack Overflow Hook\\n\\nIf `configCHECK_FOR_STACK_OVERFLOW` is enabled, add the hook in your main C file or a utilities file:\\n\\n```c\\nvoid vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {\\n    (void)pxTask;\\n    (void)pcTaskName;\\n    while (1) {\\n        // Handle stack overflow (e.g., log error, blink LED, or halt)\\n    }\\n}\\n```\\n\\n### 6. Write FreeRTOS Code\\n\\nInclude FreeRTOS in your main file and create a sample task:\\n\\n```c\\n#include \\"pico/stdlib.h\\"\\n#include <FreeRTOS.h>\\n#include <task.h>\\n\\n#define LED_PIN 25\\n\\nvoid vTaskExample(void *pvParameters) {\\n    // Initialize LED pin\\n    gpio_init(LED_PIN);\\n    gpio_set_dir(LED_PIN, GPIO_OUT);\\n\\n    while (1) {\\n        gpio_put(LED_PIN, 1);           // Turn LED on\\n        vTaskDelay(pdMS_TO_TICKS(500)); // On for 500ms\\n        gpio_put(LED_PIN, 0);           // Turn LED off\\n        vTaskDelay(pdMS_TO_TICKS(500)); // Off for 500ms\\n    }\\n}\\n\\nint main() {\\n    // Initialize Pico SDK\\n    stdio_init_all();\\n\\n    // Create task\\n    xTaskCreate(vTaskExample, \\"ExampleTask\\", 256, NULL, 1, NULL);\\n\\n    // Start scheduler\\n    vTaskStartScheduler();\\n\\n    // Should never reach here\\n    while (1);\\n}\\n\\n```\\n\\n### 7. Configure VSCode Build\\n\\nSet up VSCode to build with the Pico SDK toolchain:\\n\\n- Use the CMake Tools extension.\\n- Open the Command Palette (`Ctrl+Shift+P`), select **CMake: Configure**.\\n- Choose your kit (e.g., Pico SDK toolchain).\\n- Build the project (**CMake: Build** or `F7`).\\n\\n### 8. Build and Flash\\n\\n- Build the project in VSCode.\\n- Flash the `.uf2` file to your RP2040 (drag to the USB drive in BOOTSEL mode).\\n\\n### 9. Test the Project\\n\\n- Connect a terminal (e.g., PuTTY or `minicom`) to the RP2040\'s UART (default: USB CDC).\\n- Confirm the task prints \\"Task running\\" every second.\\n\\n## Notes\\n\\n- **Heap Size**: Tune `configTOTAL_HEAP_SIZE` (RP2040 has 264KB SRAM).\\n- **Stack Size**: Set task stack sizes (e.g., 256 in `xTaskCreate`) to avoid overflows.\\n\\n## Troubleshooting\\n\\nIf you encounter linker errors or crashes:\\n- Verify `CMakeLists.txt` paths.\\n- Check `FreeRTOSConfig.h` settings.\\n- Adjust stack and heap sizes."},{"id":"kt-kv","metadata":{"permalink":"/blog/kt-kv","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-01-kt-and-kv.md","source":"@site/blog/2025-04-01-kt-and-kv.md","title":"Motors: KT & KV","description":"Brushed DC Motor Diagram","date":"2025-04-01T00:00:00.000Z","tags":[{"inline":false,"label":"Motors","permalink":"/blog/tags/motors","description":"Motors tag description"}],"readingTime":3.57,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"kt-kv","title":"Motors: KT & KV","authors":"carlos","tags":["Motors"],"draft":false},"unlisted":false,"prevItem":{"title":"Adding FreeRTOS to an RP2040 Project","permalink":"/blog/rp2040-freertos"}},"content":"<div style={{textAlign: \'center\'}}>\\n\\n![Brushed DC Motor Diagram](/img/brushed-dc.gif)\\n\\n</div>\\n\\nIf you pick up the data sheet for a motor, one of the first things you\'ll see are the $K_V$ and $K_T$ ratings.\\n\\n[A lot](https://www.getfpv.com/iflight-xing-1303-micro-motor-5000kv.html) of motors even have these values [written on the rotor](https://www.getfpv.com/iflight-r5-2207-motor-1590kv-2050kv.html).\\n\\nBut what do they mean?\\n\\n\x3c!-- truncate --\x3e\\n\\n## 1. The Relationship Between Torque & Current\\n\\nElectric motors convert electrical energy into mechanical energy, with torque being the force that causes rotation. \\n\\n\\n\\nIn a simplified DC motor model, the generated torque $T$ is directly proportional to the armature current $I$:\\n\\n$$\\nT = K_T \\\\cdot I\\n$$\\n\\nwhere:\\n- $T$ is the torque (in Newton-meters, N\xb7m),\\n- $I$ is the current (in Amperes, A),\\n- $K_T$ is the torque constant (in N\xb7m/A).\\n\\nThis equation indicates that for every ampere of current, the motor produces a proportional amount of torque as determined by $K_T$.\\n\\n---\\n\\n## 2. The Relationship Between Speed & Voltage\\n\\nThe motor\u2019s speed\u2014typically measured as the angular velocity $\\\\omega$ (in radians per second) or in revolutions per minute (rpm)\u2014is primarily governed by the voltage applied to the motor. As the motor spins, it generates a back electromotive force (back EMF) that is proportional to its speed:\\n\\n$$\\nV = K_E \\\\cdot \\\\omega\\n$$\\n\\nwhere:\\n- $V$ is the applied voltage (in Volts, V),\\n- $\\\\omega$ is the angular velocity (in rad/s),\\n- $K_E$ is the back EMF constant (in V/(rad/s)).\\n\\nUnder no-load conditions, the back EMF nearly equals the applied voltage, linking voltage directly to speed.\\n\\n---\\n\\n## 3. Introducing $K_V$ and $K_T$\\n\\n### $K_V$: The Motor Velocity Constant\\n\\n- **Definition:** $K_V$ is typically expressed as the number of revolutions per minute (rpm) the motor achieves per volt under no load.\\n- **Units:** rpm/V.\\n- **Interpretation:** For instance, if a motor has a $K_V$ of 1000 rpm/V, applying 1 volt ideally produces 1000 rpm, and 10 volts yield 10,000 rpm.\\n\\n### $K_T$: The Motor Torque Constant\\n\\n- **Definition:** $K_T$ represents the torque produced per ampere of current.\\n- **Units:** N\xb7m/A.\\n- **Interpretation:** A motor with a $K_T$ of 0.05 N\xb7m/A will generate 0.05 N\xb7m of torque for every 1 ampere of current.\\n\\nIn ideal motors using SI units, the back EMF constant $K_E$ and the torque constant $K_T$ are numerically equal, reflecting energy conservation within the motor.\\n\\n---\\n\\n## 4. Deriving the Relationship Between $K_T$ and $K_V$\\n\\n### 4.1 Converting $K_V$ to SI-Compatible Units\\n\\n$K_V$ is typically given in rpm/V, but for consistency with SI units (where angular velocity is in rad/s), we need to convert:\\n\\n$$\\n\\\\omega = \\\\text{rpm} \\\\times \\\\frac{2\\\\pi}{60}\\n$$\\n\\nIf the motor\u2019s speed per volt is $K_V$ rpm/V, then in SI units the speed per volt becomes:\\n\\n$$\\nK_V^{\\\\prime} = K_V \\\\times \\\\frac{2\\\\pi}{60}\\n$$\\n\\n### 4.2 Relating Back EMF to Motor Speed\\n\\nThe back EMF $E$ generated in the motor is given by:\\n\\n$$\\nE = K_E \\\\cdot \\\\omega\\n$$\\n\\nUnder no-load conditions, the applied voltage $V$ almost equals the back EMF:\\n\\n$$\\nV \\\\approx K_E \\\\cdot \\\\omega\\n$$\\n\\nThus, for a given voltage, the speed is approximately:\\n\\n$$\\n\\\\omega \\\\approx \\\\frac{V}{K_E}\\n$$\\n\\nConsidering the SI conversion, where the no-load speed per volt is $K_V^{\\\\prime}$:\\n\\n$$\\n\\\\frac{V}{K_E} = K_V^{\\\\prime} \\\\cdot V\\n$$\\n\\nBy canceling $V$ (assuming $V \\\\neq 0$), we obtain:\\n\\n$$\\nK_E = \\\\frac{1}{K_V^{\\\\prime}}\\n$$\\n\\nReplacing $K_V^{\\\\prime}$ with the converted form gives:\\n\\n$$\\nK_E = \\\\frac{1}{K_V \\\\times \\\\frac{2\\\\pi}{60}} = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\n### 4.3 Establishing the Relationship with $K_T$\\n\\nFor an ideal motor, energy conservation dictates that the electrical power equals the mechanical power (ignoring losses):\\n\\n$$\\nI \\\\cdot V = T \\\\cdot \\\\omega\\n$$\\n\\nSubstitute the expressions $T = K_T \\\\cdot I$ and $V = K_E \\\\cdot \\\\omega$:\\n\\n$$\\nI \\\\cdot (K_E \\\\cdot \\\\omega) = (K_T \\\\cdot I) \\\\cdot \\\\omega\\n$$\\n\\nCanceling $I$ and $\\\\omega$ (assuming they are non-zero):\\n\\n$$\\nK_E = K_T\\n$$\\n\\nGiven the earlier result for $K_E$, it follows that:\\n\\n$$\\nK_T = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\n---\\n\\n## 5. Okay... So what?\\n\\nThe main equation care about is this one,\\n\\n$$\\nK_T = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\nAll this equation is saying is that there\'s a tradeoff between $K_T$ and $K_V$. \\n\\nAnd since $K_T$ is proportional to torque and $K_V$ is proportional to speed, then there is a fundamental tradeoff between torque _and_ speed. We can\'t just increase or decrease both."}]}}')}}]);