"use strict";(self.webpackChunkcgg_labs_docs=self.webpackChunkcgg_labs_docs||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"921k6-logger","metadata":{"permalink":"/blog/921k6-logger","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-14-921k6-logger.md","source":"@site/blog/2025-04-14-921k6-logger.md","title":"Logging Made Easy","description":"Tell me if this sounds familiar:","date":"2025-04-14T00:00:00.000Z","tags":[{"inline":false,"label":"Logging","permalink":"/blog/tags/logging","description":"Logging tag description"},{"inline":false,"label":"Serial","permalink":"/blog/tags/serial","description":"Serial tag description"}],"readingTime":1.205,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"921k6-logger","title":"Logging Made Easy","authors":"carlos","tags":["Logging","Serial"],"draft":false},"unlisted":false,"nextItem":{"title":"Adding FreeRTOS to an RP2040 Project","permalink":"/blog/rp2040-freertos"}},"content":"Tell me if this sounds familiar:\\n\\nYou\'re working on a project and want to log some UART data. Nothing too crazy though, logging to an SD card will work fine (you\'ve got a few of those lying around anyways). \\n\\n\x3c!-- truncate --\x3e\\n\\nYou look around and find a few boards on Sparkfun that can log data at a baud rate of 115.2k, but you want to log a bit faster than that. I mean, come on, even an RP2040 supports 921.6k baud nowadays.\\n\\nWhy isn\'t there a board that you can just power, plug an SD card into, hook up an RX wire, and log some data at a decent baud rate? \\n\\nNow there is.\\n\\nI\'d like to introduce you the latest thing we\'ve been cooking up in the lab: 921k6 Logger. Just hook up 5V, an RX wire, GND, and everything sent to the RX line will get logged to the SD card. Simple. \\n\\nEven better, with support for exFAT SD cards, you can log to SD cards of any size. No arbitrary 32GB limit from FAT32. We prefer the peace of mind of 128GB because, well, they\'re only 20 bucks nowadays and we\'ll never hit that limit, so why not?\\n\\n3 wires still too many for you? You can plug in the USB for power and GND and only have to connect the RX wire. That makes it easy to power with a standalone battery.\\n\\n[Pick one up today.](https://cgglabs.com/products/921k6-logger)"},{"id":"rp2040-freertos","metadata":{"permalink":"/blog/rp2040-freertos","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-07-adding-freertos-to-an-rp2040-project.md","source":"@site/blog/2025-04-07-adding-freertos-to-an-rp2040-project.md","title":"Adding FreeRTOS to an RP2040 Project","description":"We at CGG Labs love the RP2040","date":"2025-04-07T00:00:00.000Z","tags":[{"inline":false,"label":"RP2040","permalink":"/blog/tags/rp2040","description":"RP2040 tag description"},{"inline":false,"label":"Raspberry Pi Pico","permalink":"/blog/tags/raspberry-pi-pico","description":"Raspberry Pi Pico tag description"},{"inline":false,"label":"FreeRTOS","permalink":"/blog/tags/freertos","description":"FreeRTOS tag description"}],"readingTime":3.755,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"rp2040-freertos","title":"Adding FreeRTOS to an RP2040 Project","authors":"carlos","image":"/img/freertos_blog_post.png","tags":["RP2040","Raspberry Pi Pico","FreeRTOS"]},"unlisted":false,"prevItem":{"title":"Logging Made Easy","permalink":"/blog/921k6-logger"},"nextItem":{"title":"Motors: KT & KV","permalink":"/blog/kt-kv"}},"content":"We at CGG Labs love the RP2040 :heart: \\n\\nHere\'s how to use it with FreeRTOS to unlock the power of full preemptive scheduling.\\n\\n\x3c!-- truncate --\x3e\\nOr you can use our [template](https://github.com/cgglabs/Pico-FreeRTOS) and get on with building. \\n\\n# Adding FreeRTOS to an RP2040 Project in VSCode\\n\\n## Prerequisites\\n\\n- **Pico SDK**: Installed and configured.\\n- **VSCode**: Equipped with [CMake Tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools) and [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) extensions.\\n- **RP2040 Project**: A working project set up in VSCode with the Pico SDK.\\n- **Git**: Installed for cloning FreeRTOS.\\n\\n## Step-by-Step Instructions\\n\\n### 1. Download FreeRTOS\\n\\nClone the FreeRTOS repository or download a release:\\n\\n```bash\\ngit clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules\\n```\\n\\nAlternatively, grab a zip from [FreeRTOS GitHub releases](https://github.com/FreeRTOS/FreeRTOS/releases) and extract it.\\n\\n### 2. Copy FreeRTOS Files to Your Project\\n\\nOrganize FreeRTOS files in your project:\\n\\n- Create a `FreeRTOS` directory in your project root.\\n- Copy the following from the FreeRTOS repository to `FreeRTOS`:\\n  - `FreeRTOS/Source` (core files).\\n  - `FreeRTOS/Source/portable/GCC/ARM_CM0` (Cortex-M0 port for RP2040).\\n  - `FreeRTOS/Source/portable/MemMang/heap_4.c` (heap_4 is a common memory manager; others like `heap_1.c` can also be used).\\n- Copy `FreeRTOS/Source/include` to `FreeRTOS/include`.\\n\\n### 3. Add FreeRTOS Configuration File\\n\\nCreate `FreeRTOSConfig.h` in the `FreeRTOS/include` directory with a minimal configuration:\\n\\n```c\\n#ifndef FREERTOS_CONFIG_H\\n#define FREERTOS_CONFIG_H\\n\\n#define configUSE_PREEMPTION 1\\n#define configUSE_IDLE_HOOK 0\\n#define configUSE_TICK_HOOK 0\\n#define configCPU_CLOCK_HZ 125000000 // 125MHz\\n#define configTICK_RATE_HZ ((TickType_t)1000) // 1ms tick\\n#define configMAX_PRIORITIES (5)\\n#define configMINIMAL_STACK_SIZE ((uint16_t)128)\\n#define configTOTAL_HEAP_SIZE ((size_t)(10 * 1024)) // 10KB heap\\n#define configMAX_TASK_NAME_LEN (16)\\n#define configUSE_16_BIT_TICKS 0\\n#define configIDLE_SHOULD_YIELD 1\\n#define configUSE_MUTEXES 1\\n#define configQUEUE_REGISTRY_SIZE 8\\n\\n/* Memory allocation definitions */\\n#define configSUPPORT_DYNAMIC_ALLOCATION 1\\n#define configSUPPORT_STATIC_ALLOCATION 0\\n\\n/* Interrupt priorities */\\n#define configKERNEL_INTERRUPT_PRIORITY 255\\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY 191\\n\\n/* Map to Pico SDK */\\n#define configUSE_TIMERS 1\\n#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES - 1)\\n#define configTIMER_QUEUE_LENGTH 10\\n#define configTIMER_TASK_STACK_DEPTH configMINIMAL_STACK_SIZE\\n\\n#define configENABLE_MPU 0\\n\\n/* Set the following INCLUDE_* constants to 1 to include the named API function,\\n * or 0 to exclude the named API function.  Most linkers will remove unused\\n * functions even when the constant is 1. */\\n#define INCLUDE_vTaskPrioritySet               1\\n#define INCLUDE_uxTaskPriorityGet              1\\n#define INCLUDE_vTaskDelete                    1\\n#define INCLUDE_vTaskSuspend                   1\\n#define INCLUDE_vTaskDelayUntil                1\\n#define INCLUDE_vTaskDelay                     1\\n#define INCLUDE_xTaskGetSchedulerState         1\\n#define INCLUDE_xTaskGetCurrentTaskHandle      1\\n#define INCLUDE_uxTaskGetStackHighWaterMark    0\\n#define INCLUDE_xTaskGetIdleTaskHandle         0\\n#define INCLUDE_eTaskGetState                  0\\n#define INCLUDE_xTimerPendFunctionCall         0\\n#define INCLUDE_xTaskAbortDelay                0\\n#define INCLUDE_xTaskGetHandle                 0\\n#define INCLUDE_xTaskResumeFromISR             1\\n\\n#endif /* FREERTOS_CONFIG_H */\\n```\\n\\nCustomize `configTOTAL_HEAP_SIZE`, `configMAX_PRIORITIES`, etc., based on your project needs.\\n\\n### 4. Update CMakeLists.txt\\n\\nModify your `CMakeLists.txt` to include FreeRTOS:\\n\\n```cmake\\n# Add FreeRTOS as a library\\nadd_library(freertos\\n    FreeRTOS/Source/croutine.c\\n    FreeRTOS/Source/event_groups.c\\n    FreeRTOS/Source/list.c\\n    FreeRTOS/Source/queue.c\\n    FreeRTOS/Source/stream_buffer.c\\n    FreeRTOS/Source/tasks.c\\n    FreeRTOS/Source/timers.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/port.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/portasm.c\\n    FreeRTOS/Source/portable/GCC/ARM_CM0/mpu_wrappers_v2_asm.c\\n    FreeRTOS/Source/portable/MemMang/heap_4.c\\n)\\n\\n# Include FreeRTOS headers\\ntarget_include_directories(freertos PUBLIC\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS/include\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS/Source/portable/GCC/ARM_CM0\\n    ${CMAKE_CURRENT_LIST_DIR}/FreeRTOS\\n)\\n\\n# Link FreeRTOS to your executable\\ntarget_link_libraries(your_executable_name PRIVATE\\n    pico_stdlib\\n    freertos\\n)\\n```\\n\\n- Replace `your_executable_name` with your target\'s name (from `add_executable`).\\n- Ensure `pico_stdlib` is included for Pico SDK functionality.\\n\\n### 5. (optional) Implement Stack Overflow Hook\\n\\nIf `configCHECK_FOR_STACK_OVERFLOW` is enabled, add the hook in your main C file or a utilities file:\\n\\n```c\\nvoid vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {\\n    (void)pxTask;\\n    (void)pcTaskName;\\n    while (1) {\\n        // Handle stack overflow (e.g., log error, blink LED, or halt)\\n    }\\n}\\n```\\n\\n### 6. Write FreeRTOS Code\\n\\nInclude FreeRTOS in your main file and create a sample task:\\n\\n```c\\n#include \\"pico/stdlib.h\\"\\n#include <FreeRTOS.h>\\n#include <task.h>\\n\\n#define LED_PIN 25\\n\\nvoid vTaskExample(void *pvParameters) {\\n    // Initialize LED pin\\n    gpio_init(LED_PIN);\\n    gpio_set_dir(LED_PIN, GPIO_OUT);\\n\\n    while (1) {\\n        gpio_put(LED_PIN, 1);           // Turn LED on\\n        vTaskDelay(pdMS_TO_TICKS(500)); // On for 500ms\\n        gpio_put(LED_PIN, 0);           // Turn LED off\\n        vTaskDelay(pdMS_TO_TICKS(500)); // Off for 500ms\\n    }\\n}\\n\\nint main() {\\n    // Initialize Pico SDK\\n    stdio_init_all();\\n\\n    // Create task\\n    xTaskCreate(vTaskExample, \\"ExampleTask\\", 256, NULL, 1, NULL);\\n\\n    // Start scheduler\\n    vTaskStartScheduler();\\n\\n    // Should never reach here\\n    while (1);\\n}\\n\\n```\\n\\n### 7. Configure VSCode Build\\n\\nSet up VSCode to build with the Pico SDK toolchain:\\n\\n- Use the CMake Tools extension.\\n- Open the Command Palette (`Ctrl+Shift+P`), select **CMake: Configure**.\\n- Choose your kit (e.g., Pico SDK toolchain).\\n- Build the project (**CMake: Build** or `F7`).\\n\\n### 8. Build and Flash\\n\\n- Build the project in VSCode.\\n- Flash the `.uf2` file to your RP2040 (drag to the USB drive in BOOTSEL mode).\\n\\n### 9. Test the Project\\n\\n- Connect a terminal (e.g., PuTTY or `minicom`) to the RP2040\'s UART (default: USB CDC).\\n- Confirm the task prints \\"Task running\\" every second.\\n\\n## Notes\\n\\n- **Heap Size**: Tune `configTOTAL_HEAP_SIZE` (RP2040 has 264KB SRAM).\\n- **Stack Size**: Set task stack sizes (e.g., 256 in `xTaskCreate`) to avoid overflows.\\n\\n## Troubleshooting\\n\\nIf you encounter linker errors or crashes:\\n- Verify `CMakeLists.txt` paths.\\n- Check `FreeRTOSConfig.h` settings.\\n- Adjust stack and heap sizes."},{"id":"kt-kv","metadata":{"permalink":"/blog/kt-kv","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-01-kt-and-kv.md","source":"@site/blog/2025-04-01-kt-and-kv.md","title":"Motors: KT & KV","description":"Brushed DC Motor Diagram","date":"2025-04-01T00:00:00.000Z","tags":[{"inline":false,"label":"Motors","permalink":"/blog/tags/motors","description":"Motors tag description"}],"readingTime":3.57,"hasTruncateMarker":true,"authors":[{"name":"Carlos Gonzalez","title":"Chief Hacker @ CGG Labs","url":"https://cggonzalez.com/","page":{"permalink":"/blog/authors/carlos"},"socials":{"x":"https://x.com/_carlosgonzal","github":"https://github.com/cggonzal"},"imageURL":"/img/cgg.jpeg","key":"carlos"}],"frontMatter":{"slug":"kt-kv","title":"Motors: KT & KV","authors":"carlos","tags":["Motors"],"draft":false},"unlisted":false,"prevItem":{"title":"Adding FreeRTOS to an RP2040 Project","permalink":"/blog/rp2040-freertos"}},"content":"<div style={{textAlign: \'center\'}}>\\n\\n![Brushed DC Motor Diagram](/img/brushed-dc.gif)\\n\\n</div>\\n\\nIf you pick up the data sheet for a motor, one of the first things you\'ll see are the $K_V$ and $K_T$ ratings.\\n\\n[A lot](https://www.getfpv.com/iflight-xing-1303-micro-motor-5000kv.html) of motors even have these values [written on the rotor](https://www.getfpv.com/iflight-r5-2207-motor-1590kv-2050kv.html).\\n\\nBut what do they mean?\\n\\n\x3c!-- truncate --\x3e\\n\\n## 1. The Relationship Between Torque & Current\\n\\nElectric motors convert electrical energy into mechanical energy, with torque being the force that causes rotation. \\n\\n\\n\\nIn a simplified DC motor model, the generated torque $T$ is directly proportional to the armature current $I$:\\n\\n$$\\nT = K_T \\\\cdot I\\n$$\\n\\nwhere:\\n- $T$ is the torque (in Newton-meters, N\xb7m),\\n- $I$ is the current (in Amperes, A),\\n- $K_T$ is the torque constant (in N\xb7m/A).\\n\\nThis equation indicates that for every ampere of current, the motor produces a proportional amount of torque as determined by $K_T$.\\n\\n---\\n\\n## 2. The Relationship Between Speed & Voltage\\n\\nThe motor\u2019s speed\u2014typically measured as the angular velocity $\\\\omega$ (in radians per second) or in revolutions per minute (rpm)\u2014is primarily governed by the voltage applied to the motor. As the motor spins, it generates a back electromotive force (back EMF) that is proportional to its speed:\\n\\n$$\\nV = K_E \\\\cdot \\\\omega\\n$$\\n\\nwhere:\\n- $V$ is the applied voltage (in Volts, V),\\n- $\\\\omega$ is the angular velocity (in rad/s),\\n- $K_E$ is the back EMF constant (in V/(rad/s)).\\n\\nUnder no-load conditions, the back EMF nearly equals the applied voltage, linking voltage directly to speed.\\n\\n---\\n\\n## 3. Introducing $K_V$ and $K_T$\\n\\n### $K_V$: The Motor Velocity Constant\\n\\n- **Definition:** $K_V$ is typically expressed as the number of revolutions per minute (rpm) the motor achieves per volt under no load.\\n- **Units:** rpm/V.\\n- **Interpretation:** For instance, if a motor has a $K_V$ of 1000 rpm/V, applying 1 volt ideally produces 1000 rpm, and 10 volts yield 10,000 rpm.\\n\\n### $K_T$: The Motor Torque Constant\\n\\n- **Definition:** $K_T$ represents the torque produced per ampere of current.\\n- **Units:** N\xb7m/A.\\n- **Interpretation:** A motor with a $K_T$ of 0.05 N\xb7m/A will generate 0.05 N\xb7m of torque for every 1 ampere of current.\\n\\nIn ideal motors using SI units, the back EMF constant $K_E$ and the torque constant $K_T$ are numerically equal, reflecting energy conservation within the motor.\\n\\n---\\n\\n## 4. Deriving the Relationship Between $K_T$ and $K_V$\\n\\n### 4.1 Converting $K_V$ to SI-Compatible Units\\n\\n$K_V$ is typically given in rpm/V, but for consistency with SI units (where angular velocity is in rad/s), we need to convert:\\n\\n$$\\n\\\\omega = \\\\text{rpm} \\\\times \\\\frac{2\\\\pi}{60}\\n$$\\n\\nIf the motor\u2019s speed per volt is $K_V$ rpm/V, then in SI units the speed per volt becomes:\\n\\n$$\\nK_V^{\\\\prime} = K_V \\\\times \\\\frac{2\\\\pi}{60}\\n$$\\n\\n### 4.2 Relating Back EMF to Motor Speed\\n\\nThe back EMF $E$ generated in the motor is given by:\\n\\n$$\\nE = K_E \\\\cdot \\\\omega\\n$$\\n\\nUnder no-load conditions, the applied voltage $V$ almost equals the back EMF:\\n\\n$$\\nV \\\\approx K_E \\\\cdot \\\\omega\\n$$\\n\\nThus, for a given voltage, the speed is approximately:\\n\\n$$\\n\\\\omega \\\\approx \\\\frac{V}{K_E}\\n$$\\n\\nConsidering the SI conversion, where the no-load speed per volt is $K_V^{\\\\prime}$:\\n\\n$$\\n\\\\frac{V}{K_E} = K_V^{\\\\prime} \\\\cdot V\\n$$\\n\\nBy canceling $V$ (assuming $V \\\\neq 0$), we obtain:\\n\\n$$\\nK_E = \\\\frac{1}{K_V^{\\\\prime}}\\n$$\\n\\nReplacing $K_V^{\\\\prime}$ with the converted form gives:\\n\\n$$\\nK_E = \\\\frac{1}{K_V \\\\times \\\\frac{2\\\\pi}{60}} = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\n### 4.3 Establishing the Relationship with $K_T$\\n\\nFor an ideal motor, energy conservation dictates that the electrical power equals the mechanical power (ignoring losses):\\n\\n$$\\nI \\\\cdot V = T \\\\cdot \\\\omega\\n$$\\n\\nSubstitute the expressions $T = K_T \\\\cdot I$ and $V = K_E \\\\cdot \\\\omega$:\\n\\n$$\\nI \\\\cdot (K_E \\\\cdot \\\\omega) = (K_T \\\\cdot I) \\\\cdot \\\\omega\\n$$\\n\\nCanceling $I$ and $\\\\omega$ (assuming they are non-zero):\\n\\n$$\\nK_E = K_T\\n$$\\n\\nGiven the earlier result for $K_E$, it follows that:\\n\\n$$\\nK_T = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\n---\\n\\n## 5. Okay... So what?\\n\\nThe main equation care about is this one,\\n\\n$$\\nK_T = \\\\frac{60}{2\\\\pi K_V}\\n$$\\n\\nAll this equation is saying is that there\'s a tradeoff between $K_T$ and $K_V$. \\n\\nAnd since $K_T$ is proportional to torque and $K_V$ is proportional to speed, then there is a fundamental tradeoff between torque _and_ speed. We can\'t just increase or decrease both."}]}}')}}]);